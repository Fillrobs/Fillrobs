# -*- coding: utf-8 -*-
# Generated by Django 1.11.4 on 2018-05-08 19:10
from __future__ import unicode_literals

from django.db import migrations
from utilities.logger import ThreadLogger


logger = ThreadLogger(__name__)

# Copied from azure_arm/models.py because we can't reference model methods from migrations
def duplicate(AzureARMImage, image, **kwargs):
    old_instance = image
    new_instance = AzureARMImage()

    # copy all fields (CharField, BooleanField, ForeignKey, etc)
    skip_fields = ['id', 'osbuildattribute_ptr']
    for field in old_instance._meta.fields:
        field_name = field.name
        if field.name in skip_fields:
            continue
        old_value = getattr(old_instance, field_name)
        if field_name and old_value:
            logger.info(
                f'Copying field "{field_name}" to new image with value {old_value}')
            setattr(new_instance, field_name, old_value)

    # Save the new instance so it gets an ID before trying to set M2M values
    new_instance.save()

    # also copy the many-to-many fields, such as custom_fields & custom_field_options
    skip_m2m_names = []
    for many_to_many in old_instance._meta.many_to_many:
        m2m_name = many_to_many.name
        if m2m_name in skip_m2m_names:
            continue
        old_values = getattr(old_instance, m2m_name).all()
        getattr(new_instance, m2m_name).set(old_values)

    # Set any values passed in as override kwargs
    for key, val in kwargs.items():
        setattr(new_instance, key, val)

    new_instance.save()
    return new_instance

def populate_regions(apps, schema_editor):
    """
    Populate the new 'region' field on existing AzureARMImages.

    Previously, AzureARMImage instances were associated with an OS Build, which could
    have been associated with multiple environments in different regions. There was no explicit
    relationship between an image and a particular region. It was possible to
    import the same image into a different region, which would create a new 'image' instance, but it
    could not be associated with the same OS Build as another image due to view logic. However, since
    an image's OS Build could be associated with environments with varying regions, we need to duplicate
    those images because now images are filtered on a region using the new 'region' field on the AzureARMImage
    model.

    :return: None
    """
    AzureARMImage = apps.get_model('azure_arm', 'AzureARMImage')

    for image in AzureARMImage.objects.all():
        if not image.os_build:
            continue
        envs = image.os_build.environments.filter(resource_handler=image.resourcehandler)

        found_regions = []
        for env in envs:
            cfvs = env.custom_field_options.filter(field__name="node_location")
            if cfvs:
                found_regions.append(cfvs.first().str_value)

        for count, region in enumerate(found_regions):
            if count == 0:
                image.region = region
                image.save()
            else:
                new_image = duplicate(AzureARMImage, image, region=region)


class Migration(migrations.Migration):

    dependencies = [
        ('azure_arm', '0027_azurearmimage_region'),
    ]

    operations = [
        migrations.RunPython(populate_regions, migrations.RunPython.noop)
    ]
