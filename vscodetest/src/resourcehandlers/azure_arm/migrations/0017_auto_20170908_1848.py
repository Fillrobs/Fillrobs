# -*- coding: utf-8 -*-
# Generated by Django 1.11.4 on 2017-09-08 18:48
from __future__ import unicode_literals

from django.db import migrations

import cb_secrets.fields


def update_existing_azure_arm_handler_secrets(apps, schema_editor):
    """
    After updating the secret field to EncryptedTextField, save all Handlers so
    that any existing secrets get written to the db and encrypted
    (via EncryptedTextField's get_prep_value()). Normally we would freeze that custom
    logic here in a data migration, but Django's from_db_value() and get_prep_value()
    cannot be frozen, so saving objects here will always run whatever is currently in
    cb_secrets/fields.py. That means those methods cannot be modified, as the database
    values cannot be reliably migrated. If the EncryptedTextField needs to change,
    we should create a separate field and data migrate between them instead of migrating
    in place.

    As always, when running migrations, itâ€™s important to get the version of our
    AzureARMHandler model that corresponds with the point in the migration where
    you are at. This is why we use apps.get_model(...)
    """
    AzureARMHandler = apps.get_model("azure_arm", "AzureARMHandler")

    for azure_arm_handler in AzureARMHandler.objects.all():
        azure_arm_handler.save(update_fields=['secret'])


class Migration(migrations.Migration):

    dependencies = [
        ('azure_arm', '0016_auto_20170816_1444'),
    ]

    operations = [
        migrations.AlterField(
            model_name='azurearmhandler',
            name='secret',
            field=cb_secrets.fields.EncryptedTextField(help_text="A private key created for the given Active Directory application. Azure's documentation describes how to generate this type of key, but will only display the value once when it is generated.", max_length=256, verbose_name='Authentication Key'),
        ),
        migrations.RunPython(update_existing_azure_arm_handler_secrets),
    ]
