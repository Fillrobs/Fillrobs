#!/usr/bin/env python

"""
The module for the 'Auto-power control resources' recurring job.
The job is set by default to run hourly and looks at the power schedule for resources.
It checks for any resources with a power schedule set for the current hour on the current day, and will
power on or off all servers in that resource when scheduled.

The servers get powered as a group, using the deploy sequence as the order in which they are powered on or off in.
The deploy sequence is set on the server tiers in the blueprint that the resource was deployed from. The servers are
powered on in the deploy sequence and powered off in the reverse of the deploy sequence.

This also tracks and logs the servers that fail to power on or off, but continues to power the other servers in a
resource if any fail.

This uses multi-threading for resources, such that each resource gets a new thread and runs in parallel with other
resources, but the servers for each resource get powered in series.
"""

from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
import pytz


try:
    from eventlet.green import threading  # CB 7.7 and up
except ImportError:
    import threading  # CB 7.6 and earlier

if __name__ == "__main__":
    import django

    django.setup()

from django.template.defaultfilters import pluralize

from common.methods import set_progress
from infrastructure.models import ScheduledTime
from utilities.logger import _get_thread_logger

parent_thread_logger = _get_thread_logger(__name__)


def run(job=None, logger=None, **kwargs):
    now = datetime.now()

    schedules = ScheduledTime.objects.all()
    schedules_to_run = []
    for schedule in schedules:
        sched_tz = pytz.timezone(schedule.timezone)
        localized_time = datetime.now().astimezone(sched_tz)
        if (
            localized_time.hour == schedule.hour
            and localized_time.weekday() == schedule.day_of_week
        ):
            schedules_to_run.append(schedule)

    if not schedules_to_run:
        status, errors = "SUCCESS", ""
        output = "No power schedules found at this time."
        return status, output, errors

    set_progress(
        "The current hour is {} on {}, checking for resources that are scheduled "
        "to power on or off their servers at this time.".format(
            now.hour, now.strftime("%A")
        )
    )

    power_off_resources = []
    power_on_resources = []

    for schedule in schedules_to_run:

        # get the queryset of ACTIVE servers that are scheduled to be powered off
        # Note: we specifically only want active servers here - we do not want to power off servers
        # that are currently provisioning, decommissioning, or being modified.
        off_resources = schedule.resources_to_power_off.filter(lifecycle="ACTIVE")
        power_off_resources.extend(off_resources)

        # get the ACTIVE servers that are scheduled to be powered on
        # Note: we specifically only want active servers here - we do not want to power on servers
        # that are currently provisioning, decommissioning, or being modified.
        on_resources = schedule.resources_to_power_on.filter(lifecycle="ACTIVE")
        power_on_resources.extend(on_resources)

    # Run power off and power on tasks in parallel using ThreadPoolExecutor.
    # Use a with statement to ensure threads are cleaned up.
    with ThreadPoolExecutor(max_workers=100) as pool:
        # Accessing the result of the future object generated by submit()
        # causes the job to block until the power on/off task completes, so
        # store all the future objects without looking at the results until all
        # the tasks have been kicked off.
        future_map = {}
        total_attempts = 0
        for resource in power_on_resources:
            power_on_servers = resource.server_set.order_by("service_item__deploy_seq")
            set_progress(
                "Resource '{}' is set to power on {} server{}".format(
                    resource,
                    power_on_servers.count(),
                    pluralize(power_on_servers.count()),
                )
            )
            # check for any servers that are no longer associated with a service item, aka server tier.
            # this is caused by a user deleting a server tier from the blueprint after the resource was deployed.
            power_on_tierless_servers = resource.server_set.filter(service_item=None)
            if power_on_tierless_servers:
                power_on_tierless_servers_str = ", ".join(
                    [svr.hostname for svr in power_on_tierless_servers]
                )
                set_progress(
                    "Found {} server{} without a server tier: '{}' which will be powered on first.".format(
                        power_on_tierless_servers.count(),
                        pluralize(power_on_tierless_servers.count()),
                        power_on_tierless_servers_str,
                    )
                )
            total_attempts += power_on_servers.count()
            power_on_servers_str = ", ".join([svr.hostname for svr in power_on_servers])

            set_progress(
                "Will power on a total of {} server{} in sequence: {}".format(
                    power_on_servers.count(),
                    pluralize(power_on_servers.count()),
                    power_on_servers_str,
                )
            )

            future = pool.submit(threaded_power_on, resource, job)
            future_map[future] = ("on", resource)

        for resource in power_off_resources:
            power_off_servers = resource.server_set.order_by(
                "-service_item__deploy_seq"
            )
            set_progress(
                "Resource '{}' is set to power off {} server{}".format(
                    resource,
                    power_off_servers.count(),
                    pluralize(power_off_servers.count()),
                )
            )
            # check for any servers that are no longer associated with a service item, aka server tier.
            # this is caused by a user deleting a server tier from the blueprint after the resource was deployed.
            power_off_tierless_servers = resource.server_set.filter(service_item=None)
            if power_off_tierless_servers:
                power_off_tierless_servers_str = ", ".join(
                    [svr.hostname for svr in power_off_tierless_servers]
                )
                set_progress(
                    "Found {} server{} without a server tier: '{}' which will be powered off last.".format(
                        power_off_tierless_servers.count(),
                        pluralize(power_off_tierless_servers.count()),
                        power_off_tierless_servers_str,
                    )
                )
            total_attempts += power_off_servers.count()
            power_off_servers_str = ", ".join(
                [svr.hostname for svr in power_off_servers]
            )

            set_progress(
                "Will power off a total of {} server{} in sequence: {}".format(
                    power_off_servers.count(),
                    pluralize(power_off_servers.count()),
                    power_off_servers_str,
                )
            )

            future = pool.submit(threaded_power_off, resource, job)
            future_map[future] = ("off", resource)

        total_server_failures = {"on": 0, "off": 0}
        total_server_successes = {"on": 0, "off": 0}
        # Use as_completed to process the result of each task as it completes
        for future in as_completed(future_map):
            on_off, resource = future_map[future]
            try:
                successes, failures = future.result()
            except Exception as exc:
                logger.info(
                    "Exception during power {} of resource {}: {}".format(
                        on_off, resource, exc
                    ),
                    exc_info=True,
                )
                successes, failures = None, None
            if failures:
                for server in failures:
                    set_progress(
                        "Failed to power {on_off} server '{server}' for resource '{resource}'.".format(
                            on_off=on_off, server=server, resource=resource
                        )
                    )
                    total_server_failures[on_off] += 1
            if successes:
                total_server_successes[on_off] += len(successes)

    if total_server_failures["on"] or total_server_failures["off"]:
        failures_msg = "Failed to power on {} and power off {} of {} server{}.".format(
            total_server_failures["on"],
            total_server_failures["off"],
            total_attempts,
            pluralize(total_attempts),
        )
        return ("WARNING", failures_msg, "")

    final_servers_powered_on = (
        total_server_successes["on"] - total_server_failures["on"]
    )
    final_servers_powered_off = (
        total_server_successes["off"] - total_server_failures["off"]
    )

    output = (
        "{} servers powered on from {} resources. \n"
        "{} servers powered off from {} resources.".format(
            final_servers_powered_on,
            len(power_on_resources),
            final_servers_powered_off,
            len(power_off_resources),
        )
    )

    status, errors = "SUCCESS", ""
    return status, output, errors


def threaded_power_on(resource, job):
    thread = threading.current_thread()
    thread.job = job
    thread.logger = parent_thread_logger
    return resource.power_on_servers()


def threaded_power_off(resource, job):
    thread = threading.current_thread()
    thread.job = job
    thread.logger = parent_thread_logger
    return resource.power_off_servers()


if __name__ == "__main__":
    run()
