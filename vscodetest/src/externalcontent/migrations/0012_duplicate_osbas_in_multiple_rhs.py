# -*- coding: utf-8 -*-
# Generated by Django 1.11.4 on 2018-05-16 20:27
from __future__ import unicode_literals

from django.db import migrations

from utilities.logger import ThreadLogger

logger = ThreadLogger(__name__)


def duplicate_osbas_in_multiple_rhs(apps, schema_editor):
    """
    In the past, we used to add an OSBA to multiple resource handlers. For
    example, this happened when two vCenters had templates with the same name.

    The new resourcehandler ForeignKey on OSBA is designed to prevent this, but
    the 0007_add_osbas_to_base_field_20180501_2319 only added the existing OSBAs
    to a single RH, even if it used to belong to multiple. This caused templates
    to seem to disappear from RHs.

    Since OSBAs can only belong to a single handler now, this migration creates
    a copy of each OSBA that used to belong to multiple RHs. It detects them by
    looking for templates that are in old_os_build_attributes but are missing
    from the new os_build_attributes.
    """
    ResourceHandler = apps.get_model('resourcehandlers', 'ResourceHandler')

    for handler in ResourceHandler.objects.exclude(resource_technology__name='IPMI'):
        try:
            real_type = handler.real_type
        except AttributeError as e:
            # if the handler had no submodel, then the getattr will fail (it will try to getattr on resourcehandler)
            # this could be a number of other errors, so stick with a generic log message.
            logger.info("OSBAS were not copied from handler {}.".format(handler))
            logger.debug(e)
            continue

        # get the submodel instance
        SubModel = apps.get_model(real_type.app_label, real_type.model)
        real_handler = SubModel.objects.get(id=handler.id)

        if not hasattr(real_handler, 'old_os_build_attributes'):
            logger.info("{} handler has no attribute 'old_os_build_attributes'.".format(real_handler))
            continue

        # Find any OSBAs that show up in old relationship but not new one
        old_osbas = real_handler.old_os_build_attributes.all()
        new_osba_ids = handler.os_build_attributes.values_list('id', flat=True)
        missing_osbas = [osba for osba in old_osbas if osba.id not in new_osba_ids]

        # Create copies of the OSBAs with the new resourcehandler FK
        for osba in missing_osbas:
            previous_handler = osba.resourcehandler
            osba.id = None
            osba.osbuildattribute_ptr_id = None
            osba.resourcehandler = handler
            osba.save()
            logger.info(
                "Template {t} on {rh} already exists on {rh2}, creating a "
                "duplicate template.".format(
                    t=osba.template_name, rh=handler.name, rh2=previous_handler.name
                )
            )


class Migration(migrations.Migration):

    dependencies = [
        ('externalcontent', '0011_auto_20180503_1803'),
    ]

    operations = [
        migrations.RunPython(duplicate_osbas_in_multiple_rhs, migrations.RunPython.noop)
    ]
